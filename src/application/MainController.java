/**
 * Class: MainController
 * Description: This is the controller for the main application, it is separated into three major sections
 * Employees tab, Shifts tab and Rooms tab (future re-factor could separate this out to three separate controllers).
 * This class connects the gui (javafx) and captures all user actions and routes them to the appropriate functions in 
 * the CareHome instance. 
 * 
 * @author Marton Marek
 */
package application;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;
import java.util.ResourceBundle;
import application.auditor.ActionUpdateEmployee;
import application.auditor.ActionViewResidentDetails;
import application.auditor.Auditor;
import application.exceptions.AuditDataAccessException;
import application.exceptions.InvalidBedIndexException;
import application.exceptions.OutsideOfShiftTimeException;
import application.exceptions.ScheduleOutOfComplianceException;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.*;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.GridPane;
import javafx.scene.paint.Paint;
import javafx.scene.shape.Rectangle;
import javafx.stage.FileChooser;

public class MainController implements Initializable, Serializable {
	
	
	/**
	 * Autogenerated default serial version ID
	 */
	private static final long serialVersionUID = 1L;
	
	//the main tabs of the application
	@FXML
    private Tab tabRooms;
	@FXML
    private Tab tabEmployees;
	@FXML
    private Tab tabShifts;
	@FXML
	private Tab tabAudit;
	
	//Bed naming convention - bed_{ward number}_{bed number}
	//Ward and bed controls
	@FXML
    private Rectangle bed_1_1;
    @FXML
    private Rectangle bed_1_2;
    @FXML
    private Rectangle bed_1_3;
    @FXML
    private Rectangle bed_1_4;
    @FXML
    private Rectangle bed_1_5;
    @FXML
    private Rectangle bed_1_6;
    @FXML
    private Rectangle bed_1_7;
    @FXML
    private Rectangle bed_1_8;
    @FXML
    private Rectangle bed_1_9;
    @FXML
    private Rectangle bed_1_10;
    @FXML
    private Rectangle bed_1_11;
    @FXML
    private Rectangle bed_1_12;
    @FXML
    private Rectangle bed_1_13;
    @FXML
    private Rectangle bed_1_14;
    @FXML
    private Rectangle bed_1_15;
    @FXML
    private Rectangle bed_1_16;
    @FXML
    private Rectangle bed_1_17;
    @FXML
    private Rectangle bed_1_18;
    @FXML
    private Rectangle bed_1_19;
    @FXML
    private Rectangle bed_2_1;
    @FXML
    private Rectangle bed_2_2;
    @FXML
    private Rectangle bed_2_3;
    @FXML
    private Rectangle bed_2_4;
    @FXML
    private Rectangle bed_2_5;
    @FXML
    private Rectangle bed_2_6;
    @FXML
    private Rectangle bed_2_7;
    @FXML
    private Rectangle bed_2_8;
    @FXML
    private Rectangle bed_2_9;
    @FXML
    private Rectangle bed_2_10;
    @FXML
    private Rectangle bed_2_11;
    @FXML
    private Rectangle bed_2_12;
    @FXML
    private Rectangle bed_2_13;
    @FXML
    private Rectangle bed_2_14;
    @FXML
    private Rectangle bed_2_15;
    @FXML
    private Rectangle bed_2_16;
    @FXML
    private Rectangle bed_2_17;
    @FXML
    private Rectangle bed_2_18;
    @FXML
    private Rectangle bed_2_19;
    
    //represents the two wards
    @FXML
    private GridPane gridWard1;
    @FXML
    private GridPane gridWard2;
    
    //buttons and labels for the Wards Screen
    @FXML
    private Label lblSelectedBed;
    @FXML
    private Button buttonAddResident;
    @FXML
    private Button buttonRemoveResident;
    @FXML
    private Button buttonCheckDetails;
    @FXML
    private Button buttonMoveResident;
    @FXML
    private Button buttonNewPrescription;
    @FXML
    private Button buttonAdminMedicine;
    @FXML
    private Label lblInstruction;
    @FXML
    private Label lblSelectedResident;
        

    //employee controls
	@FXML
	private TextField firstName;
	@FXML
	private TextField surname;
	@FXML
	private TextField username;
	@FXML
	private TextField password;
	@FXML
	private ChoiceBox<String> employeeTypeChoiceBox; 
	@FXML 
	private DatePicker datePicker;
	@FXML
	private Button buttonDelete;
		
	//Employee Table 
	@FXML
    private TableView<AbstractUser> employeeTableView;
    @FXML
    private TableColumn<AbstractUser, String> firstNameCol;
    @FXML
    private TableColumn<AbstractUser, String> surnameCol;
    @FXML
    private TableColumn<AbstractUser, String> dobCol;
    @FXML
    private TableColumn<AbstractUser, String> jobCol;
    
    //Medical staff list for the schedule table (only medical staff can have a schedule)
    @FXML
    private TableView<MedicalStaff> schedule_employeeTableView;
    @FXML
    private TableColumn<MedicalStaff, String> schedule_firstNameCol;
    @FXML
    private TableColumn<MedicalStaff, String> schedule_surnameCol;
    @FXML
    private TableColumn<MedicalStaff, String> schedule_jobCol;
    
    //The shift selector dropdowns
    @FXML
    private ComboBox<String> cmbMonday;
    @FXML
    private ComboBox<String> cmbTuesday;
    @FXML
    private ComboBox<String> cmbWednesday;
    @FXML
    private ComboBox<String> cmbThursday;
    @FXML
    private ComboBox<String> cmbFriday;
    @FXML
    private ComboBox<String> cmbSaturday;
    @FXML
    private ComboBox<String> cmbSunday;

    //These labels display the shift times (start / end) for the selected employee
    @FXML
    private Label lblMondayShiftTime;
    @FXML
    private Label lblTuesdayShiftTime;
    @FXML
    private Label lblWednesdayShiftTime;
    @FXML
    private Label lblThursdayShiftTime;
    @FXML
    private Label lblFridayShiftTime;
    @FXML
    private Label lblSaturdayShiftTime;
    @FXML
    private Label lblSundayShiftTime;
    
    //This label displays the selected employees name at the top of the screen
    @FXML
    private Label lblSelectedName;
    
    //shift compliance label (warns if out of compliance with doctors shifts)
    @FXML
    private Label lblCompliance;
    
    //shows the current login username
    @FXML
    private Label lblLoggedIn;
    
    //Audit tab elements
    @FXML
    private DatePicker dateAuditStart;
    @FXML
    private DatePicker dateAuditEnd;
    @FXML
    private ComboBox<String> cmbAuditResident;
    @FXML
    private ComboBox<String> cmbAuditEmployee;
    
    //This is used as the alert window to provide messages to the user
    Alert userAlert = new Alert(AlertType.NONE);
    
    //Keeps track of the employee lists
    ObservableList<AbstractUser> employeeList = FXCollections.observableArrayList();  
    
    ObservableList<MedicalStaff> medicalStaffList = FXCollections.observableArrayList();

	//holds the business logic 
	CareHome home;
	
	//used to identify the name of the package where the classes belong to
	private final String PACKAGENAME = new String("application");
	
	//list of all employee types
	private String[] employeeTypes; 
	
	//currently selected bed
	private Rectangle currentlySelectedBed;
	
	//Bed and selection colours
	String black = "#000000";
	String white = "#FFFFFF";
	String blue = "#3538e6";
	String red = "#e63535";
	String orange = "#ff8800";
	
	//move bed state. When this state is on selecting a second bed will attempt to move
	//residents from one bed to another.
	private boolean moveBedState = false;
	
	/**
	 * Implements the initialize method from the Initializable interface. This method will 
	 * initialise the entire controller and gui interface components as it loads. (Similar to a 
	 * constructor). It connects all of the needed components and loads required data.
	 */
	@Override
	public void initialize(URL arg0, ResourceBundle arg1) {
		
		home = CareHome.getInstance();
		
		employeeTypes = Employees.getEmployeeTypes();
		//add all of the employee types to the employee types choice box
		//eg. (doctor, manager, nurse)
		employeeTypeChoiceBox.getItems().addAll(employeeTypes);
		
		//populate the observerable lists that serve our employee tableviews..
		
		//this will get all of our employees for the employee list..
		List<AbstractUser> list = (List<AbstractUser>) home.getEmployees().getEmployeeList();
		employeeList.addAll(FXCollections.observableList(list));
		
		//this will get only medical staff for the shift employee list..
		List<MedicalStaff> medList = (List<MedicalStaff>) home.getEmployees().getMedicalEmployeeList();
		medicalStaffList.addAll(FXCollections.observableList(medList));
		
		//employee screen employee list
		firstNameCol.setCellValueFactory(new PropertyValueFactory<AbstractUser, String>("firstName"));
		surnameCol.setCellValueFactory(new PropertyValueFactory<AbstractUser, String>("surname"));
		dobCol.setCellValueFactory(new PropertyValueFactory<AbstractUser, String>("dob"));
		jobCol.setCellValueFactory(new PropertyValueFactory<AbstractUser, String>("job"));
		
		//schedule screen employee list
		schedule_firstNameCol.setCellValueFactory(new PropertyValueFactory<MedicalStaff, String>("firstName"));
		schedule_surnameCol.setCellValueFactory(new PropertyValueFactory<MedicalStaff, String>("surname"));
		schedule_jobCol.setCellValueFactory(new PropertyValueFactory<MedicalStaff, String>("job"));
		
		employeeTableView.setItems(employeeList);	
		schedule_employeeTableView.setItems(medicalStaffList);
		
		//adds listeners to the shift time selection comboboxes
		addComboBoxListener(cmbMonday);
		addComboBoxListener(cmbTuesday);
		addComboBoxListener(cmbWednesday);
		addComboBoxListener(cmbThursday);
		addComboBoxListener(cmbFriday);
		addComboBoxListener(cmbSaturday);
		addComboBoxListener(cmbSunday);
		
		//update the bed colours on the room screen
		loadResidents();
		
		//initialise the enabled functions in the application based on the type of user that is logged in
		initialiseRoleBasedFunctions(home.getCurrentUser());
		
		//set the logged in label
		lblLoggedIn.setText(home.getCurrentUser().getUsername());
		
		//check current shift compliance
		updateComplianceMessage();
	}
	
	
	/**
	 * this function will enable/ disable functions in the application based on the type of user that 
	 * is logged in. (Eg. Manager, Doctor, Nurse). tabs and buttons are greyed out if function not
	 * relevant for specified user
	 * @param user
	 */
	private void initialiseRoleBasedFunctions(AbstractUser user) {
		
		//Firstly the managers responsibilities include:
		// Add/modify staff details and shifts
		// add new residents to vacant bed 
		
		if (user instanceof Manager) {
			//managers can't move beds, check resident details, or add/edit/administer prescriptions
			//so disable those buttons in the wards screen
			buttonCheckDetails.setDisable(true);
			buttonMoveResident.setDisable(true);
			buttonNewPrescription.setDisable(true);
			buttonAdminMedicine.setDisable(true);

		} 
		else if (user instanceof Doctor) {
			buttonAddResident.setDisable(true);
			buttonRemoveResident.setDisable(true);
			buttonAdminMedicine.setDisable(true);
			buttonMoveResident.setDisable(true);
			
			tabEmployees.setDisable(true);
			tabShifts.setDisable(true);
			tabAudit.setDisable(true);
			
		}
		else if (user instanceof Nurse) {
			buttonAddResident.setDisable(true);
			buttonRemoveResident.setDisable(true);
			buttonNewPrescription.setDisable(true);
			
			tabEmployees.setDisable(true);
			tabShifts.setDisable(true);
			tabAudit.setDisable(true);
		}
	}
	
	/**
	 * logs the current user out of the system and re-displays the login screen
	 */
	public void logout() {
		
		userAlert.setAlertType(AlertType.CONFIRMATION);
		userAlert.setContentText("Are you sure you want to logout?");
		
		Optional<ButtonType> userResponse = userAlert.showAndWait();
		if (userResponse.get() == ButtonType.OK){
			Main main = new Main();

			try {
				//save the current state and logout
				CareHome.getInstance().saveToFile();
				
				//get back into the login screen
				main.sceneChange("Login.fxml", "Resi-Care v0.1 Login", 600, 350);
			} catch (IOException e) {
				userAlert.setAlertType(AlertType.ERROR);
				userAlert.setContentText("Critical Error could not log out, please restart the application");
				userAlert.show();	
			}
		} 
	}

	
	//
	
	/**
	 * adds a listener to the shift combo boxes. When the combo box is updated, the selectShift 
	 * method is called that will update the selected employees shift time based on what's selected
	 * in the combo box. 
	 * @param combo
	 */
	private void addComboBoxListener(ComboBox<String> combo) {
		combo.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
		    if (newValue != null) {
		        selectShift(combo);
		    }
		});
	}

	
	/**********************************************************************************************
	 * EMPLOYEES TAB
	 */
	
	/**
	 * Called when the user click the "clear all" button. it clears all of the employee fields
	 * @param e
	 */
	public void clearAll(ActionEvent e) {
		updateEmployeeFields(null);
	}
	

	/**
	 * Called when the "ADD" employee button is pressed. the method uses reflection to create
	 * the new employee object based on the selected job role in the combobox. This method would not
	 * need to change when new employee types are added to this application. As long as the employee
	 * type is listed in the combo box with the same name as the new employee type, this will work.
	 * 
	 * @param e
	 */
	public void addEmployee(ActionEvent e) {
	
		//create employee based on what job role was selected 
		//instead of hard coding this, let's use the string input
		//from the employee type choice box and use reflection to create the new object
		String employeeType = employeeTypeChoiceBox.getValue();
		LocalDate dob = datePicker.getValue();
		
		//check if all of the employee fields are filled out, if not we need to throw an error
		if (employeeType == null) {
			userAlert.setAlertType(AlertType.WARNING);
			userAlert.setContentText("No job role was selected! Please select a job for the new employee.");
			userAlert.show();
		}
		else if (dob == null) {
			userAlert.setAlertType(AlertType.WARNING);
			userAlert.setContentText("No Date of Birth was selected! Please select a Date of Birth for the new employee.");
			userAlert.show();
		}
		else if (!home.validateNewEmployeeUsername(username.getText())) {
			userAlert.setAlertType(AlertType.WARNING);
			userAlert.setContentText("That username already exists, please type a different one.");
			userAlert.show();			
		}
		else if (firstName.getText().isBlank() || surname.getText().isBlank() || 
				 username.getText().isBlank() || password.getText().isBlank()) {
			
			userAlert.setAlertType(AlertType.WARNING);
			userAlert.setContentText("Must fill out all details to add a user.");
			userAlert.show();	
		}
		else if (firstName.getLength() > 30 || surname.getLength() > 30 ||
				username.getLength() > 30 || password.getLength() > 30) {
			
			userAlert.setAlertType(AlertType.WARNING);
			userAlert.setContentText("All fields must be less than 30 characters in length!");
			userAlert.show();	
		}
		else {
			try {			
				//creates a new user class based on the job role that was selected 
				@SuppressWarnings("unchecked")
				Class<AbstractUser> newUser = (Class<AbstractUser>) Class.forName(PACKAGENAME + "." + employeeType);
				
				//we can then build the user object..
				//need to build a parameter list for getDeclaredConstructor 
				Class<?>[] params = new Class[5];
				params[0] = String.class;
				params[1] = String.class;
				params[2] = String.class;
				params[3] = String.class;
				params[4] = LocalDate.class;
				
				//build the arguments list for the new object instance
				Object[] args = new Object[5];
				args[0] = firstName.getText();
				args[1] = surname.getText();
				args[2] = username.getText();
				args[3] = password.getText();
				args[4] = datePicker.getValue();
				
				//use the params (4 Strings) to create the AbstractUser Constructor with those
				//4 parameters (name, surname, username, password)
				Constructor<AbstractUser> userConstructor = newUser.getDeclaredConstructor(params);

				//now using the gathered information from the form, pass the 5 strings
				//into a new instance of the class
				AbstractUser newEmployee = userConstructor.newInstance(args);
				home.addEmployee(newEmployee);
				
				//now add the employee into the tableview
				employeeList.add(newEmployee);
				
				//now clear the employee fields by giving update method a null value
				updateEmployeeFields(null);

				//if medical staff was created, they also has a shift schedule
				if (newEmployee instanceof MedicalStaff) {
					//if the new employee is a medical staff we can safely type cast and add it to our medical staff list
					medicalStaffList.add((MedicalStaff)newEmployee);
					ShiftList newShiftList = new ShiftList();
					
					//then assign the empty shiftlist to the new employee and save it in the schedule
					home.updateShift((MedicalStaff)newEmployee, newShiftList);
				}
	
			} catch (ClassNotFoundException e1) {
				userAlert.setAlertType(AlertType.ERROR);
				userAlert.setContentText("Critical Error has occured and we could not add the user, please restart the application");
				userAlert.show();	
			} catch (InstantiationException e1) {
				userAlert.setAlertType(AlertType.ERROR);
				userAlert.setContentText("Critical Error has occured and we could not add the user, please restart the application");
				userAlert.show();	
			} catch (IllegalAccessException e1) {
				userAlert.setAlertType(AlertType.ERROR);
				userAlert.setContentText("Critical Error has occured and we could not add the user, please restart the application");
				userAlert.show();	
			} catch (IllegalArgumentException e1) {
				userAlert.setAlertType(AlertType.ERROR);
				userAlert.setContentText("Critical Error has occured and we could not add the user, please restart the application");
				userAlert.show();	
			} catch (InvocationTargetException e1) {
				userAlert.setAlertType(AlertType.ERROR);
				userAlert.setContentText("Critical Error has occured and we could not add the user, please restart the application");
				userAlert.show();	
			} catch (NoSuchMethodException e1) {
				userAlert.setAlertType(AlertType.ERROR);
				userAlert.setContentText("Critical Error has occured and we could not add the user, please restart the application");
				userAlert.show();	
			} catch (SecurityException e1) {
				userAlert.setAlertType(AlertType.ERROR);
				userAlert.setContentText("Critical Error has occured and we could not add the user, please restart the application");
				userAlert.show();	
			} catch (AuditDataAccessException ade) {
				userAlert.setAlertType(AlertType.ERROR);
				userAlert.setContentText("Critical Database Error. Please check the Database");
				userAlert.show();	
			}
			
		}
		
	}
	
	/**
	 * This is a private helper function that will display all of the given users
	 * details in the employee screen. It can also be passed null, if we want
	 * to clear all of the employee fields. 
	 * @param employee
	 */
	private void updateEmployeeFields(AbstractUser employee) {
		
		//if no employee is given clear the fields 
		if (employee == null) {
			firstName.clear();
			surname.clear();
			username.clear();
			password.clear();
			employeeTypeChoiceBox.setValue(null);
			datePicker.setValue(null);			
			datePicker.getEditor().clear();
		}
		else {
			firstName.setText(employee.getFirstName());
			surname.setText(employee.getSurname());
			username.setText(employee.getUsername());
			password.setText(employee.getPassword());
			employeeTypeChoiceBox.setValue(employee.getJob());
			datePicker.setValue(employee.getDob());
		}
	}
	
	/** 
	 * Called when the "Delete" employee button is pressed. It will use the employee list
	 * to get the selected employee, then delete it from the system. (note, employees are not deleted
	 * from the audit database so that auditing can be done on previous employees).
	 * 
	 * @param e
	 */
	public void deleteEmployee(ActionEvent e) {
		
		AbstractUser selectedEmployee = employeeTableView.getSelectionModel().getSelectedItem();
		
		//the first thing we need to check it to make sure we don't allow
		//the deletion of the last manager in the system.
		if (home.isLastManager() && (selectedEmployee instanceof Manager)) {
			userAlert.setAlertType(AlertType.WARNING);
			userAlert.setContentText("You can not delete the last manager from the system. Please create a new one prior to deleting this one.");
			userAlert.show();
			return;
		}
		
		//make sure an employee is selected..
		if (selectedEmployee != null) {
			
			employeeTableView.getItems().remove(selectedEmployee);
			schedule_employeeTableView.getItems().remove(selectedEmployee);
			
			//need to refresh the tableview
			employeeTableView.refresh();
			schedule_employeeTableView.refresh();
			
			//delete the employee from our employee list
			home.deleteEmployee(selectedEmployee);
			
			//clear the shifts 
			clearShifts();

			//if the action was initiated by the "delete button" then clear the fields
			//(otherwise, the update method may also call this method in which case we do not want to clear the fields..
			if (((Button)e.getSource()).getText().equals(buttonDelete.getText())) {
				updateEmployeeFields(null);
			}
			
			//check if we are in compliance..
			try {
				home.checkCompliance();
				lblCompliance.setText("");
				
			} catch (ScheduleOutOfComplianceException sce) {
				//if we are not in compliance display the non-compliance message 
				lblCompliance.setText("X - SCHEDULE OUT OF COMPLIANCE! THERE NEEDS "
						+ "TO BE AT LEAST ONE (1) NURSE ASSIGNED TO EACH MORNING AND "
						+ "EACH AFTERNOON SHIFT. THERE NEEDS TO BE ONE (1) DOCTOR ASSIGNED "
						+ "PER DAY (ANYTIME BETWEEN 9AM - 5PM).");
			}
			
		}
		else {
			userAlert.setAlertType(AlertType.WARNING);
			userAlert.setContentText("No employee selected! Select an employee from the list to delete.");
			userAlert.show();
		}
		
	}
	
	/**
	 * Called when the "UPDATE" employee button is pressed. If an employee is selected and 
	 * its fields have been updated by the user, this method will update the employees
	 * details based on the input fields. if job role is changed, the user will be prompted
	 * to confirm that the employees shifts will be deleted. 
	 * 
	 * @param e
	 */
	public void updateEmployee(ActionEvent e) {
		
		AbstractUser selectedEmployee = employeeTableView.getSelectionModel().getSelectedItem();
		
		if (selectedEmployee != null) {
			//if the job was updated, we need to re-create the user with a new job role..
			if (!selectedEmployee.getJob().equals(employeeTypeChoiceBox.getValue())) {
				userAlert.setAlertType(AlertType.CONFIRMATION);
				userAlert.setContentText("Updating the employees job, will delete any existing shifts from the schedule. Are you sure?");
				
				//validate with the user so they know this will also delete the existing shiftlist
				Optional<ButtonType> userResponse = userAlert.showAndWait();
				if (userResponse.get() == ButtonType.OK){
					
					//we need to delete user and re-create with new job object
					deleteEmployee(e);
					//now recreate a new object
					addEmployee(e);
				} 
			}
			else {
				//update every field (except for job type)
				selectedEmployee.setFirstName(firstName.getText());
				selectedEmployee.setSurname(surname.getText());
				selectedEmployee.setUsername(username.getText());
				selectedEmployee.setPassword(password.getText());
				selectedEmployee.setDob(datePicker.getValue());

				//save action into our audit list
				Auditor.getInstance().saveToAudit(new ActionUpdateEmployee(home.getCurrentUser(), selectedEmployee));
			}
			
			//need to refresh the tableview
			employeeTableView.refresh();
			schedule_employeeTableView.refresh();
			
			//now clear the user fields
			updateEmployeeFields(null);
		}
		else {
			userAlert.setAlertType(AlertType.WARNING);
			userAlert.setContentText("No employee selected! Select an employee from the list to update.");
			userAlert.show();
		}
	}
	
	/**
	 * Called when an employee is clicked on in the Employee screen. It will get
	 * the clicked employees details and display them in the employee tab fields
	 * @param e
	 */
	public void selectEmployee(MouseEvent e) {
			
		AbstractUser selectedEmployee = employeeTableView.getSelectionModel().getSelectedItem();
		
		//show this employee in the employee fields..
		updateEmployeeFields(selectedEmployee);
	}
	
	
	/**********************************************************************************************
	 * SHIFT TAB
	 */
	
	/**
	 * Called when an employee is selected on the Shift screen. It gets the selected employees
	 * shift details and displays them in the shifts section 
	 * @param e
	 */
	public void selectShiftList(MouseEvent e) {
		//get the selected employee
		AbstractUser selectedEmployee = schedule_employeeTableView.getSelectionModel().getSelectedItem();
		
		if (selectedEmployee != null) {	
			//displays each days shift times
			displayShifts((MedicalStaff)selectedEmployee);
			
			//update the label display at top of screen with employee name
			lblSelectedName.setText(selectedEmployee.getFirstName() + " " + selectedEmployee.getSurname());
		}
		else {
			userAlert.setAlertType(AlertType.WARNING);
			userAlert.setContentText("No employee selected! Select an employee from the list first.");
			userAlert.show();
		}
	}
	
	/**
	 * Clears all of the shift details from the screen
	 */
	public void clearShifts() {
		cmbMonday.getItems().clear();
		cmbTuesday.getItems().clear();
		cmbWednesday.getItems().clear();
		cmbThursday.getItems().clear();
		cmbFriday.getItems().clear();
		cmbSaturday.getItems().clear();
		cmbSunday.getItems().clear();
		
		//shift labels too..
		lblMondayShiftTime.setText("-");
		lblTuesdayShiftTime.setText("-");
		lblWednesdayShiftTime.setText("-");
		lblThursdayShiftTime.setText("-");
		lblFridayShiftTime.setText("-");
		lblSaturdayShiftTime.setText("-");
		lblSundayShiftTime.setText("-");
		
		//selected name label too
		lblSelectedName.setText("");
	}
	
	
	/**
	 * given a selected medical employee, this will display the shift time for 
	 * each day in the shift combo boxes.
	 * @param staff
	 */
	private void displayShifts(MedicalStaff staff) {
		
		ShiftList sList = home.getEmployeeShiftList(staff);
		
		//Monday
		cmbMonday.getItems().clear();
		cmbMonday.getItems().addAll(staff.getAllowedShiftStartTimes());
		cmbMonday.setValue(sList.getShift(Day.MONDAY).getShiftStartHourString());
		
		//Tuesday
		cmbTuesday.getItems().clear();
		cmbTuesday.getItems().addAll(staff.getAllowedShiftStartTimes());
		cmbTuesday.setValue(sList.getShift(Day.TUESDAY).getShiftStartHourString());
		
		//Wednesday
		cmbWednesday.getItems().clear();
		cmbWednesday.getItems().addAll(staff.getAllowedShiftStartTimes());
		cmbWednesday.setValue(sList.getShift(Day.WEDNESDAY).getShiftStartHourString());
		
		//Thursday
		cmbThursday.getItems().clear();
		cmbThursday.getItems().addAll(staff.getAllowedShiftStartTimes());
		cmbThursday.setValue(sList.getShift(Day.THURSDAY).getShiftStartHourString());

		//Friday
		cmbFriday.getItems().clear();
		cmbFriday.getItems().addAll(staff.getAllowedShiftStartTimes());
		cmbFriday.setValue(sList.getShift(Day.FRIDAY).getShiftStartHourString());
		
		//Saturday
		cmbSaturday.getItems().clear();
		cmbSaturday.getItems().addAll(staff.getAllowedShiftStartTimes());
		cmbSaturday.setValue(sList.getShift(Day.SATURDAY).getShiftStartHourString());
		
		//Sunday
		cmbSunday.getItems().clear();
		cmbSunday.getItems().addAll(staff.getAllowedShiftStartTimes());
		cmbSunday.setValue(sList.getShift(Day.SUNDAY).getShiftStartHourString());
	}
	

	/**
	 * This will display the start and end time of the shift for a specific day 
	 * (located under the drop down menu)
	 * @param lbl
	 * @param day
	 * @param staff
	 */
	private void displayShiftTime(Label lbl, Day day, MedicalStaff staff) {
		
		ShiftList sList = home.getEmployeeShiftList(staff);
		
		if (sList.getShift(day).getShiftStartHour() == 0) {
			lbl.setText("-");
			return;
		}
		
		String shiftTime = sList.getShift(day).getShiftStartHourString();
		String ShiftEnd = sList.getShift(day).getShiftEndHourString();
		
		lbl.setText(shiftTime + " - " + ShiftEnd);
	}
	

	/**
	 * Called when a start shift time is selected from the drop down choice box
	 * @param combo
	 */
	private void selectShift(ComboBox<String> combo) {
		
		//get the selected employee
		MedicalStaff selectedStaff = (MedicalStaff) schedule_employeeTableView.getSelectionModel().getSelectedItem();
		
		String endShiftTime = String.valueOf(selectedStaff.getShiftLength()); 
		
		//get the current shift list for the selected staff member
		ShiftList sList = home.getEmployeeShiftList(selectedStaff);
		
		//update the day that was selected
		sList.updateShift(getSelectedShiftDay(combo), combo.getValue(), endShiftTime);
		
		//update the shift time label 
		displayShiftTime(getSelectedShiftLabel(combo), getSelectedShiftDay(combo), selectedStaff);
		
		//check for shift compliance
		updateComplianceMessage();
	}
	
	/**
	 * Updates the shift compliance message based on the result of the call to checkCompliance()
	 */
	private void updateComplianceMessage() {
		//check if we are in compliance..
		try {
			home.checkCompliance();
			lblCompliance.setText("");
			
		} catch (ScheduleOutOfComplianceException sce) {
			
			lblCompliance.setText("X - SCHEDULE OUT OF COMPLIANCE! THERE NEEDS TO BE AT LEAST ONE (1) "
					+ "NURSE ASSIGNED TO EACH MORNING AND EACH AFTERNOON SHIFT. THERE NEEDS TO BE ONE "
					+ "(1) DOCTOR ASSIGNED PER DAY (ANYTIME BETWEEN 9AM - 5PM).");
		}
	}
	

	/**
	 * this method will find out which combobox was selected on the shift list
	 * and return the corresponding Day (Enumerator) 
	 * @param combo
	 * @return Day enum
	 */
	private Day getSelectedShiftDay(ComboBox<String> combo) {
		
		switch (combo.getId()) {
		
		case "cmbMonday":
			return Day.MONDAY;
		
		case "cmbTuesday":
			return Day.TUESDAY;
		
		case "cmbWednesday":
			return Day.WEDNESDAY;
		
		case "cmbThursday":
			return Day.THURSDAY;
		
		case "cmbFriday":
			return Day.FRIDAY;
		
		case "cmbSaturday":
			return Day.SATURDAY;
		
		case "cmbSunday":
			return Day.SUNDAY;
		
		default:
			return null;
		}
	}
	
	/**
	 * This method returns the corresponding label to a shift combo box
	 * @param combo
	 * @return Label (shift)
	 */
	private Label getSelectedShiftLabel(ComboBox<String> combo) {
		
		switch (combo.getId()) {
		
		case "cmbMonday":
			return lblMondayShiftTime;
		
		case "cmbTuesday":
			return lblTuesdayShiftTime;
		
		case "cmbWednesday":
			return lblWednesdayShiftTime;
		
		case "cmbThursday":
			return lblThursdayShiftTime;
		
		case "cmbFriday":
			return lblFridayShiftTime;
		
		case "cmbSaturday":
			return lblSaturdayShiftTime;
		
		case "cmbSunday":
			return lblSundayShiftTime;
		
		default:
			return null;
		}
	}

	
	/**********************************************************************************************
	 *  ROOMS TAB
	 */
	
	/**
	 * Is called when a Rectangle (Bed) is clicked by the user on the screen. 
	 * this method can have two states depending on whether we are moving a resident
	 * or just selecting one. the state is determined by moveBedState
	 * @param e
	 */
	public void selectBed(MouseEvent e) {
		
		//get the id of the bed that was selected
		String bedID = e.getPickResult().getIntersectedNode().getId();

		//split the string based on the naming convention bed_{ward number}_{room number}
		String [] tokens = bedID.split("_");
		
		//setup some easier to read variables
		int targetWardID = Integer.parseInt(tokens[1]);
		int targetBedID = Integer.parseInt(tokens[2]);
		
		//is destination bed isolated
		boolean destBedIso = isBedIsolated(targetWardID, targetBedID);
		
		//if we are in the move state, attempt to move the resident to the newly selected bed..
		if(moveBedState) {
			
			//first get our resident to move..
			Resident residentAtSource = home.getResident(currentlySelectedBed.getId());
			boolean sourceNeedIso = residentAtSource.isNeedForIso();
			
			//source bed ID
			String[] sourceTokens = currentlySelectedBed.getId().split("_");
			int sourceWardID = Integer.parseInt(sourceTokens[1]);
			int sourceBedID = Integer.parseInt(sourceTokens[2]);
			
			//is the source bed isolated
			boolean sourceBedIso = isBedIsolated(sourceWardID, sourceBedID);
			boolean destinationNeedIso;
			//get the destination bed
			Rectangle destinationBed = (Rectangle)(e.getPickResult().getIntersectedNode());

			//get the destination resident
			Resident residentAtDestination = home.getResident(bedID);

			//if there is an existing resident, we have to swap the two residents
			if (residentAtDestination != null) {
				
				destinationNeedIso = residentAtDestination.isNeedForIso();
				
				//but we can only do that if the need for isolation is adhered to..
				//so need to check if either resident has a need for isolation..
				
				//if neither resident has an iso  need OR 
				//they both have an iso need AND both beds are isolated, we can swap..
				if ( (!sourceNeedIso && !destinationNeedIso) || 
						( (sourceNeedIso && destinationNeedIso) && (destBedIso && sourceBedIso) ) || 
						( (sourceNeedIso && destBedIso) && (!destinationNeedIso && !sourceBedIso) )  ||
						( (destinationNeedIso && sourceBedIso) && (!sourceNeedIso && !destBedIso) ) ) {
					
					try {
						//set the new destination with the source resident
						home.replaceResident(targetWardID, targetBedID, residentAtSource);
						
						//set the color of the bed based on the sex of the resident
						if (residentAtSource.getGender() == Sex.MALE) {
							destinationBed.setFill(Paint.valueOf(blue));
						}
						else {
							destinationBed.setFill(Paint.valueOf(red));
						}
						
						//then set the new source with the destination resident
						home.replaceResident(sourceWardID, sourceBedID, residentAtDestination);
					}
					catch (InvalidBedIndexException ie) {
						userAlert.setAlertType(AlertType.ERROR);
						userAlert.setContentText("Critical Error, could not move resident. Please reset the application.");
						userAlert.show();

						//reset the instruction label
						lblInstruction.setText("");
						return;
					}
					
					//set the color of the bed based on the sex of the resident
					if (residentAtDestination.getGender() == Sex.MALE) {
						currentlySelectedBed.setFill(Paint.valueOf(blue));
					}
					else {
						currentlySelectedBed.setFill(Paint.valueOf(red));
					}
					
					//reset the instruction label
					lblInstruction.setText("");
					
				}
				else {
					userAlert.setAlertType(AlertType.ERROR);
					userAlert.setContentText("Resident isolation requirements are not met. Please choose alternate beds.");
					userAlert.show();
					
					//reset the instruction label
					lblInstruction.setText("");
				}

			}
			else {
				//if there is no resident at the destination bed, then we just check to make sure
				//need for isolation is still adhered to
				if ( (!sourceNeedIso) || (sourceNeedIso && destBedIso) ) {
					
					//if either there is no need for iso OR
					//there is a need for iso AND the destination room is isolated..then we can proceed..
					
					//confirm the move with the user, through dialog box
					userAlert.setAlertType(AlertType.CONFIRMATION);
					userAlert.setContentText("Are you sure you want to move the resident to a new bed?");
									
					//validate with the user so they know this will also delete the existing shiftlist
					Optional<ButtonType> userResponse = userAlert.showAndWait();
					if (userResponse.get() == ButtonType.OK){
						
						//if OK then do the move..
						try {
							home.setResident(targetWardID, targetBedID, residentAtSource);
						} catch (IndexOutOfBoundsException e1) {
							userAlert.setAlertType(AlertType.ERROR);
							userAlert.setContentText("Critical Error. Please restart the application.");
							userAlert.show();
						} catch (AuditDataAccessException e1) {
							userAlert.setAlertType(AlertType.ERROR);
							userAlert.setContentText("Critical Database Error. Please check the database.");
							userAlert.show();
						}
						
						//set the color of the bed based on the sex of the resident
						if (residentAtSource.getGender() == Sex.MALE) {
							destinationBed.setFill(Paint.valueOf(blue));
						}
						else {
							destinationBed.setFill(Paint.valueOf(red));
						}
						
						//we then delete the resident from the previous bed..
						home.deleteResident(sourceWardID, sourceBedID);
						
						//set the bed colour back to white as well
						currentlySelectedBed.setFill(Paint.valueOf(white));	

					} 
					
					//reset the instruction label
					lblInstruction.setText("");

				}
				else {
					//if isolation rules were not adhered too, we throw an error message
					userAlert.setAlertType(AlertType.ERROR);
					userAlert.setContentText("The resident requires isolation but the destination bed is not isolated!");
					userAlert.show();
					
					//reset the instruction label
					lblInstruction.setText("");
					
				}

			}
		}
		else {  //otherwise just select the bed as normal
			
			//first print out the bed id details to the screen
			lblSelectedBed.setText("Ward: " + tokens[1] + ", Bed Number: " + tokens[2]);
			
			//now get the resident name assigned to this bed 
			Resident clickedResident = home.getResident(bedID);
			
			if (clickedResident != null) {
				lblSelectedResident.setText(clickedResident.getFirstName() + " " + clickedResident.getSurname());
				
			}
			else {
				//if no resident was returned from clicking on the bed..
				lblSelectedResident.setText("");
			}
			
			highlightSelectedBed(e);
			
			//update currently selected bed
			currentlySelectedBed = (Rectangle)(e.getPickResult().getIntersectedNode());
			
			//and update the currently selected resident 
			home.setSelectedResident(clickedResident);
		
		}
		//reset the moving bed state
		moveBedState = false;
	}
	
	
	/**
	 * returns true if the given bed ID is a bed that is isolated. returns false otherwise. 
	 * @param ward
	 * @param bed
	 * @return boolean
	 */
	private boolean isBedIsolated(int ward, int bed) {
		if (bed == 1) {
			return true;
		}
		
		return false;
	}
	
	/**
	 * highlights the border of the selected bed (rectangle) orange 
	 * @param e
	 */
	private void highlightSelectedBed(MouseEvent e) {
		
		//reset the currently selected bed to normal (no highlight)
		if(currentlySelectedBed != null) {
			currentlySelectedBed.setStrokeWidth(1.0);
			currentlySelectedBed.setStroke(Paint.valueOf(black));
		}
		
		//then highlight the newly selected bed. 
		((Rectangle)e.getPickResult().getIntersectedNode()).setStrokeWidth(2.0);
		((Rectangle)e.getPickResult().getIntersectedNode()).setStroke(Paint.valueOf(orange));
	}


	/**
	 * Called when the add resident button is pressed. it then opens a dialog box to get residents information
	 * then adds the resident to the currently selected bed 
	 * @param e
	 */
	public void addResident(ActionEvent e) {
		//check to make sure that we have a bed selected and that its empty
		if(currentlySelectedBed == null) {
			//if no bed is selected we can not continue
			userAlert.setAlertType(AlertType.ERROR);
			userAlert.setContentText("No bed selected. Please select a bed first!");
			userAlert.show();
			
		}
		else {
			Resident selected = home.getResident((currentlySelectedBed.getId()));
			if (selected != null) {
				userAlert.setAlertType(AlertType.ERROR);
				userAlert.setContentText("There is already a resident in this bed!");
				userAlert.show();		
			}
			else {
				//we can add the resident to this empty bed
				Resident newResident = getResidentDetails();
				
				//if the new resident hasn't been filled out correctly (and we have a null object), we can't continue
				if (newResident !=  null) {
					String [] tokens = currentlySelectedBed.getId().split("_");

					try {
						home.setResident(Integer.parseInt(tokens[1]), Integer.parseInt(tokens[2]), newResident);
						//set the color of the bed based on the sex of the resident
						if (newResident.getGender() == Sex.MALE) {
							currentlySelectedBed.setFill(Paint.valueOf(blue));
						}
						else {
							currentlySelectedBed.setFill(Paint.valueOf(red));
						}
						
					} catch (IndexOutOfBoundsException e1) {
						userAlert.setAlertType(AlertType.ERROR);
						userAlert.setContentText("Critical Error adding resident. Please restart the application.");
						userAlert.show();
					} catch (AuditDataAccessException e1) {
						userAlert.setAlertType(AlertType.ERROR);
						userAlert.setContentText("Critical Database Error. Please check the database.");
						userAlert.show();
					}
				}
			}
		}
	}
	
	/**
	 * This opens the dialog box to get the residents details during the add process.
	 * once it collects the information from the user a Resident object is returned. 
	 * if cancel is pressed on dialog box null is returned 
	 * 
	 * @return Resident 
	 */
	private Resident getResidentDetails() {
		
		//display the dialog box and get all of the details
		try {
			FXMLLoader fxmlLoader = new FXMLLoader();
			fxmlLoader.setLocation(getClass().getResource("ResidentDialogBox.fxml"));
			DialogPane residentDialogBox = fxmlLoader.load();
			
			//load the controller
			ResidentController residentController = fxmlLoader.getController();

			//display the dialog box
			Dialog<ButtonType> dialog = new Dialog<>();
			dialog.setDialogPane(residentDialogBox);
			dialog.setTitle("Add New Resident");
			dialog.getDialogPane().lookupButton(ButtonType.OK).setDisable(true);
			Optional<ButtonType> clicked = dialog.showAndWait();

			//if the OK button is clicked we save the resident details 
			if (clicked.get() == ButtonType.OK) {
				return residentController.getResident();
			}
			
		}
		catch (Exception e){
			System.out.println(e.getMessage() + "  " + e.toString());
		}
		//if the user cancel's out of the dialog box, return null
		return null;
	}
	
	/**
	 * This is called when the remove resident button is pressed. it will then remove the
	 * selected resident (in the selected bed) from the system. 
	 * NOTE: the resident is not removed from the audit database so historical audits can 
	 * be performed even after the resident has been removed from the system. 
	 * 
	 * @param e
	 */
	public void deleteResident(ActionEvent e) {
		//check if a bed is selected 
		if(currentlySelectedBed == null) {
			userAlert.setAlertType(AlertType.ERROR);
			userAlert.setContentText("No bed selected. Please select a bed first!");
			userAlert.show();
		}
		else {
			//get the currently selected resident 
			Resident selected = home.getResident(currentlySelectedBed.getId());
			if (selected == null) {
				userAlert.setAlertType(AlertType.ERROR);
				userAlert.setContentText("There is no resident in this bed. Please select a bed with a resident!");
				userAlert.show();
			}
			else {
				//delete the selected resident
				String [] tokens = currentlySelectedBed.getId().split("_");
				home.deleteResident(Integer.parseInt(tokens[1]), Integer.parseInt(tokens[2]));
				
				//set the color of the bed back to white
				currentlySelectedBed.setFill(Paint.valueOf(white));	
			}	
		}
	}
	
	/**
	 * This is called when the "Check details" button is pressed by a medical staff.
	 * It takes the selected resident and displays their details in a dialog box.
	 * @param e
	 */
	public void displayResidentDetails(ActionEvent e) {
		
		try {
			//check if user is still in shift time and can perform this action
			home.validateShift();
		
			//check if a bed is selected 
			if(currentlySelectedBed == null) {
				userAlert.setAlertType(AlertType.ERROR);
				userAlert.setContentText("No bed selected, please select a bed first!");
				userAlert.show();
			}
			else {
				
				Resident selected = home.getResident(currentlySelectedBed.getId());
				if (selected == null) {
					userAlert.setAlertType(AlertType.ERROR);
					userAlert.setContentText("There is no resident in this bed. Please select a bed with a resident!");
					userAlert.show();				
				}
				else {
					//display the dialog box and get all of the details
					try {
						FXMLLoader fxmlLoader = new FXMLLoader();
						fxmlLoader.setLocation(getClass().getResource("ResidentDetails.fxml"));
						DialogPane residentDetails = fxmlLoader.load();
								
						//load the controller
						ResidentDetailsController residentDetailsController = fxmlLoader.getController();
								
						//load the currently selected residents details to the resident details controller
						residentDetailsController.setResident(selected);
	
						//display the dialog box
						Dialog<ButtonType> dialog = new Dialog<>();
						dialog.setDialogPane(residentDetails);
						dialog.setTitle("Resident Details");
						dialog.showAndWait();
						
						//add this action to the audit log
						Auditor.getInstance().saveToAudit(new ActionViewResidentDetails(home.getCurrentUser(), selected));
								
					}
					catch (Exception ex){
						System.out.println(ex.getMessage() + "  " + ex.toString());
					}
	
				}	
			}
		}
		catch (OutsideOfShiftTimeException oe) {
			userAlert.setAlertType(AlertType.WARNING);
			userAlert.setContentText("You can not perform the action because you are outside of your shift hours. "
					+ "Please log out of the system and log back in during your shift time.");
			userAlert.show();
		}
	}
	
	
	/**
	 * This method will load the residents into their beds (basically update the colour 
	 * of each bed at load time).
	 */
	private void loadResidents() {
		
		for(Node node: gridWard1.getChildrenUnmodifiable()) {
			
			for(Node bed: ((Parent) node).getChildrenUnmodifiable()) {

				//get the resident in the bed (if one exists)
				Resident resident = home.getResident(bed.getId());
				
				if (resident != null) {
					
					//set the color of the bed based on the sex of the resident
					if (resident.getGender() == Sex.MALE) {
						((Rectangle)bed).setFill(Paint.valueOf(blue));
					}
					else {
						((Rectangle)bed).setFill(Paint.valueOf(red));
					}
				}
				
			}
		}
		
		for(Node node: gridWard2.getChildrenUnmodifiable()) {
			
			for(Node bed: ((Parent) node).getChildrenUnmodifiable()) {

				//get the resident in the bed (if one exists)
				Resident resident = home.getResident(bed.getId());
				
				if (resident != null) {
					
					//set the color of the bed based on the sex of the resident
					if (resident.getGender() == Sex.MALE) {
						((Rectangle)bed).setFill(Paint.valueOf(blue));
					}
					else {
						((Rectangle)bed).setFill(Paint.valueOf(red));
					}
				}
				
			}
		}
	}
	
	/**
	 * This is called when the "move resident" button is pressed. It will confirm there is a selected resident
	 * then ask the user to click on the destination bed. if all validations check on the resident will be moved
	 * or swapped if destination also has a resident. This action can only be performed by medical staff that are
	 * currently within their shift hours. If they log in during their shift hours and remain logged in after their
	 * shift ends the validateShift method will throw an exception. 
	 * 
	 * @param e
	 */
	public void moveResident(ActionEvent e) {
		
		try {
			//check if user is still in shift time 
			home.validateShift();
		
			//first check if the bed contains a resident. 
			if(currentlySelectedBed == null) {
				userAlert.setAlertType(AlertType.ERROR);
				userAlert.setContentText("No bed selected. Please select a bed first!");
				userAlert.show();
			}
			else {
				
				Resident selected = home.getResident(currentlySelectedBed.getId());
				if (selected == null) {		
					userAlert.setAlertType(AlertType.ERROR);
					userAlert.setContentText("There is no resident in this bed. Please select a bed with a resident!");
					userAlert.show();
				}
				else {
					
					//set the moveBeds state to true so we can pick a second bed to move to..
					moveBedState = true;
					
					//provide the instruction on screen to select a second bed
					lblInstruction.setText("Select the bed to move this resident to.");
				}
				
			}
			
		}
		catch (OutsideOfShiftTimeException oe) {
			userAlert.setAlertType(AlertType.WARNING);
			userAlert.setContentText("You can not perform the action because you are outside of your shift hours. "
					+ "Please log out of the system and log back in during your shift time.");
			userAlert.show();
		}

	}
	
	/**
	 * Called when the 'edit prescription' button is pressed. It will load a screen that allows
	 * a doctor (that is currently on shift) to add a new prescription 
	 * @param e
	 */
	public void prescriptionDetails(ActionEvent e) {
		
		try {
			//check if user is still in shift time 
			home.validateShift();
		
			//check if a bed is selected 
			if(currentlySelectedBed == null) {
				userAlert.setAlertType(AlertType.ERROR);
				userAlert.setContentText("No bed selected, please select a bed first!");
				userAlert.show();
			}
			else {
						
				Resident selected = home.getResident(currentlySelectedBed.getId());
				if (selected == null) {
					userAlert.setAlertType(AlertType.ERROR);
					userAlert.setContentText("There is no resident in this bed. Please select a bed with a resident!");
					userAlert.show();				
				}
				else {
					//display the dialog box and get all of the details
					try {
						
						//load the currently selected residents details to the resident details controller
						//we now do this by loading it into the carehome 
						home.setSelectedResident(selected);
						
						FXMLLoader fxmlLoader = new FXMLLoader();
						fxmlLoader.setLocation(getClass().getResource("PrescriptionDialog.fxml"));
						//load the controller
						DialogPane prescription = fxmlLoader.load();
	
						//display the dialog box
						Dialog<ButtonType> dialog = new Dialog<>();
						dialog.setDialogPane(prescription);
						dialog.setTitle("Prescription Details");
						dialog.showAndWait();
			
					}
					catch (Exception ex){
						System.out.println(ex.getMessage() + "  " + ex.toString());
					}
	
				}	
			}
		}
		catch (OutsideOfShiftTimeException oe) {
			userAlert.setAlertType(AlertType.WARNING);
			userAlert.setContentText("You can not perform the action because you are outside of your shift hours. "
					+ "Please log out of the system and log back in during your shift time.");
			userAlert.show();
		}
	}
	
	/**
	 * This method is called when the 'administer medicine' button is pressed. It allows
	 * a nurse (that is currently on shift) to record an administration of a prescription
	 * or a "once-off" medicine (That can be manually entered on the screen). This action 
	 * will also be saved into the audit database for long term record keeping. 
	 * 
	 * @param e
	 */
	public void administerMedicine(ActionEvent e) {

		try {
			//check is user is still in shift time 
			home.validateShift();
		
			//check if a bed is selected 
			if(currentlySelectedBed == null) {
				userAlert.setAlertType(AlertType.ERROR);
				userAlert.setContentText("No bed selected, please select a bed first!");
				userAlert.show();
			}
			else {
						
				Resident selected = home.getResident(currentlySelectedBed.getId());
				if (selected == null) {
					userAlert.setAlertType(AlertType.ERROR);
					userAlert.setContentText("There is no resident in this bed. Please select a bed with a resident!");
					userAlert.show();					
				}
				else {
					//display the dialog box and allow a nurse to administer medicine
					try {
						
						FXMLLoader fxmlLoader = new FXMLLoader();
						fxmlLoader.setLocation(getClass().getResource("AdministerMedicine.fxml"));
						//load the controller
						DialogPane administer = fxmlLoader.load();
	
						//display the dialog box
						Dialog<ButtonType> dialog = new Dialog<>();
						dialog.setDialogPane(administer);
						dialog.setTitle("Administer Medicine");
						dialog.showAndWait();
			
					}
					catch (Exception ex){
						System.out.println(ex.getMessage() + "  " + ex.toString());
					}
	
				}	
			}
		}
		catch (OutsideOfShiftTimeException oe) {
			userAlert.setAlertType(AlertType.WARNING);
			userAlert.setContentText("You can not perform the action because you are outside of your shift hours. "
					+ "Please log out of the system and log back in during your shift time.");
			userAlert.show();
		}
	}
	
	
	/**********************************************************************************************
	 *  AUDIT TAB
	 */
	
	
	public void auditReport(ActionEvent e) {
		
		//if no employee or resident are selected we pass null values 
		String eUUID = null;
		String rUUID = null;
		
		//get the employee ID selected from the drop down
		if (cmbAuditEmployee.getValue() != null) {
			
			String[] tokens = cmbAuditEmployee.getValue().split(":");
			
			eUUID = new String(tokens[1].trim());
		}		
		
		//get the resident ID selected from the drop down
		if (cmbAuditResident.getValue() != null) {
			String[] tokens = cmbAuditResident.getValue().split(":");
			
			rUUID = new String(tokens[1].trim());
		}
		
		try {
			ArrayList<String> report = home.getAuditReport(dateAuditStart.getValue().atStartOfDay(), 
															dateAuditEnd.getValue().atStartOfDay(), 
															eUUID, 
															rUUID);
			
			
			//ask the user to specify a location and file name for the save audit file
			FileChooser saveFileDialog = new FileChooser();
			
			File saveAuditFile = saveFileDialog.showSaveDialog(null);
			
			if (saveAuditFile != null) {
				Iterator<String> iter = report.iterator();
				
				FileWriter fileWriter;
				try {
					fileWriter = new FileWriter(saveAuditFile, true);
					BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
				    PrintWriter printWriter = new PrintWriter(bufferedWriter);
				    
				    while(iter.hasNext()) {
				    	printWriter.println(iter.next());
					}

				    printWriter.close();
			    
				} catch (IOException ioe) {
					ioe.printStackTrace();
				}

			}

		} 
		catch (AuditDataAccessException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		catch (NullPointerException ne) {
			userAlert.setAlertType(AlertType.ERROR);
			userAlert.setContentText("Please select start and end dates for report!");
			userAlert.show();
		}
	}
	
	public void displayAuditEmployees(MouseEvent e) {
		cmbAuditEmployee.getItems().clear();
		try {
			cmbAuditEmployee.getItems().addAll(home.getAllEmployeesList());
		} catch (AuditDataAccessException e1) {
			userAlert.setAlertType(AlertType.ERROR);
			userAlert.setContentText("No employees could be retrieved from the database.");
			userAlert.show();
		}
		
	}
	
	public void displayAuditResidents(MouseEvent e) {
		cmbAuditResident.getItems().clear();
		try {
			cmbAuditResident.getItems().addAll(home.getAllResidentsList());
		} 
		catch (AuditDataAccessException e1) {
			userAlert.setAlertType(AlertType.ERROR);
			userAlert.setContentText("No residents could be retrieved from the database.");
			userAlert.show();
		}
		
	}
	
	
}
