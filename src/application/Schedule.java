/**
 * Class: Schedule
 * Description: Stores every employees shift listin a hashmap that can be acccess via the employee ID. 
 * Also does the compliance check that shows whether there is at least one nurse assigned to each morning and afternoon shift
 * and at least one doctor assigned for a minimum of one hour per day.
 * 
 * @author Marton Marek
 */


package application;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;

public class Schedule implements Serializable {
	
	/**
	 * Autogenerated default serial version ID
	 */
	private static final long serialVersionUID = 1L;
	
	//to store all shifts based on employee ID as the key
	HashMap<String, ShiftList> shiftMap; 

	
	/**
	 * Default constructor 
	 */
	public Schedule() {
		shiftMap = new HashMap<String, ShiftList>();
	}
	
	/**
	 * returns the size of the schedule (This is how many employee shifts in contains)
	 * @return int
	 */
	public int size() {
		return shiftMap.size();
	}
	
	/**
	 * Given an employee object, this will delete their entire shift list
	 * @param staff
	 */
	public void deleteShiftList(MedicalStaff staff) {
		String id = staff.getEmployeeID();
		
		//check if the ID exists...
		if (shiftMap.containsKey(id)) {
			//then just set the map value to the new list
			shiftMap.remove(id);					
		}
	}

	/**
	 * Given an employee object and shift list, this will replace the existing shift list
	 * or add the new shift list as new if one doesn't already exist
	 * @param staff
	 * @param list
	 */
	public void updateShiftList(MedicalStaff staff, ShiftList list) {
		
		String id = staff.getEmployeeID();
		//check if the ID exists...
		if (shiftMap.containsKey(id)) {
			//then just set the map value to the new list
			shiftMap.replace(id, list);
		}
		else {		
			//if it doesn't already exists, add as new shiftlist
			shiftMap.put(id, list);
		}
	}
	
	/**
	 * Given an employee object, this will return the shift list object. If the employee
	 * does not exist, this will return null
	 * @param staff
	 * @return ShiftList or null
	 */
	public ShiftList getShiftList(MedicalStaff staff) {
		String id = staff.getEmployeeID();
		if (shiftMap.containsKey(id)) {
			return shiftMap.get(id);
		}
		else {
			return null;
		}
	}
	
	/**
	 * This method will check if we have a doctor scheduled for every day of the week AND
	 * if we have every nurse shift covered (morning and afternoon)
	 * if we do it will return true and false otherwise
	 * @param employees
	 * @return boolean
	 */
	public boolean checkScheduleCompliance(Employees employees) {
		
		ArrayList<Boolean> doctorScheduled = new ArrayList<Boolean>();
		ArrayList<Boolean> nurseMorningScheduled = new ArrayList<Boolean>();
		ArrayList<Boolean> nurseNightScheduled = new ArrayList<Boolean>();
		
		
		//first scenario is that we have no shifts at all..
		if (shiftMap.size() == 0) {
			return false;
		} //or we have no employees..
		else if(employees == null) {
			return false;
		}
		else if(employees.employees.size() == 0) {
			return false;
		}
		
		ShiftList current = new ShiftList();
		
		//first we initialise the compliance array
		for (int i = 0; i < current.length(); i++) {
			doctorScheduled.add(false);
			nurseMorningScheduled.add(false);
			nurseNightScheduled.add(false);
			
		}
		
		//iterate through each shiftlist, check if it belongs to a doctor 
		//then assign a tick to every day they are assigned. We can terminate early if we reach compliance
		for (String n : shiftMap.keySet()) {
			
			//check if the ID belongs to a Doctor
			AbstractUser user = employees.getEmployee(n);
			
			//check if this employee is a doctor
			if (user instanceof Doctor) {
				//if we have a doctor, get the shift list and iterate through it..
				current = shiftMap.get(n);
				
				for (int i = 0; i < current.length(); i++) {
					
					if(current.getList().get(i).getShiftStartHour() != 0) {
						doctorScheduled.set(i, true);
					}
				}
			}
			else if (user instanceof Nurse) {
				
				//get the nurse shift
				current = shiftMap.get(n);
				
				for (int i = 0; i < current.length(); i++) {
					
					if(current.getList().get(i).getShiftStartHour() == Nurse.NURSE_SHIFT_MORNING_START) {
						nurseMorningScheduled.set(i, true);
					}
					else if (current.getList().get(i).getShiftStartHour() == Nurse.NURSE_SHIFT_NIGHT_START) {
						nurseNightScheduled.set(i, true);
					}
				}
			}
		}
		
		//now check the compliance array and if it contains any false values we are out of compliance
		for (int i = 0; i < current.length(); i++) {
			if (!doctorScheduled.get(i) || !nurseMorningScheduled.get(i) || !nurseNightScheduled.get(i)) {
				return false;
			}
		}
		
		//if we couldn't find out of compliance return true to mean we are in compliance
		return true;
	}
	
	/**
	 * Given an employee object, thsi will return true if they are currently on shift
	 * and false if they are out of shift time. This is used to check whether the user
	 * can login or if already logged in whether they can perform system actions.
	 * 
	 * @param user
	 * @return boolean
	 */
	public boolean hasShift(AbstractUser user) {
		
		//managers are 'always' on shift (ie. they can use system anytime)
		if (user instanceof Manager) {
			return true;
		}
		else if (user instanceof MedicalStaff) {
			
			//get the shiftlist of this staff..
			ShiftList list = getShiftList((MedicalStaff)user);
			
			//if there are no shifts for this user..
			if (list == null) {
				return false;
			}

			//get the day and time and check against staff's schedule
			LocalDateTime date = LocalDateTime.now();
			int dayIndex = date.getDayOfWeek().getValue();
			int hour = date.getHour();
			
			//get the shift using the day index (date provides index starting from 1 so, we need to minus 1)
			Shift shift = list.getShift(dayIndex - 1);
			
			//if there is no shift on the day, we can return false
			if (shift.getShiftStartHour() == 0) {
				return false;
			}
			else if ((shift.getShiftStartHour() <= hour) && (shift.getShiftEndHour() > hour)) {
				//if we are between the start and end hour, return true
				return true;
			}
		}
		return false;
		
	}
	
}
